To wrap things up and set you up for a smooth start tomorrow, here is a summary of our progress and the specific ground we need to cover for the **Legacy System Integration** and the **Bonus Task**.

### 1. Tomorrow’s Priority: Legacy Store Manager Testing

Since we are moving this to a separate test file, we will be focusing on the **Integration** and **Resilience** of the `LegacyStoreManagerGateway`.

**The test scenarios we will implement:**

* **Post-Commit Trigger:** Ensure the legacy system is only called *after* the database transaction successfully finishes.
* **Error Isolation:** Verify that if the Legacy System throws an error, the Monolith doesn't "roll back" the already successful database change.
* **Data Integrity:** Ensure the `Store` object passed to the legacy system contains the ID generated by the database.

---

### 2. The Bonus Task: Fulfillment Logic

Once the legacy tests are solid, we will tackle the complex many-to-many relationships between **Warehouses**, **Products**, and **Stores**.

**We will need to implement the following constraints:**
| Constraint | Target Entity | Limit |
| :--- | :--- | :--- |
| **Product Distribution** | Max Warehouses per (Product + Store) | **2** |
| **Store Logistics** | Max Warehouses per Store | **3** |
| **Warehouse Density** | Max Product types per Warehouse | **5** |

---

### 3. Your "To-Do" List for Tomorrow

If you want to get a head start, you can prepare these two things:

1. **New Test File:** Create `src/test/java/.../stores/LegacyStoreManagerTest.java`.
2. **New Domain Model:** Think about a `Fulfillment` or `Association` entity that can hold the `warehouseId`, `productId`, and `storeId`.

It’s been a very productive session—you've built a solid architectural foundation for both the Store and Warehouse domains.

Understood! Let's get everything ready for your morning session.

To set the stage, we’ll focus on the **Legacy System Resilience** and the data modeling for the **Bonus Fulfillment Task**.

### 1. Legacy Store Manager Integration Test

We will create a dedicated test to verify that our synchronization logic is "Fault Tolerant." The goal is to prove that if the legacy system is down, the Monolith still functions correctly because the database transaction has already been secured.

**Boilerplate for `LegacyStoreManagerTest.java`:**

```java
package com.fulfilment.application.monolith.stores;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import io.quarkus.test.InjectMock;
import io.quarkus.test.junit.QuarkusTest;
import io.restassured.http.ContentType;
import org.junit.jupiter.api.Test;

@QuarkusTest
public class LegacyStoreManagerTest {

    @InjectMock
    LegacyStoreManagerGateway legacyStoreManagerGateway;

    @Test
    public void testMonolithResilienceWhenLegacyFails() {
        // Arrange: Simulate a total failure of the legacy system
        doThrow(new RuntimeException("Legacy Connection Timeout"))
            .when(legacyStoreManagerGateway).createStoreOnLegacySystem(any(Store.class));

        Store newStore = new Store("RESILIENT_SHOP");
        newStore.quantityProductsInStock = 100;

        // Act & Assert: The API should still return 201 Created 
        // because the DB transaction finished successfully before the legacy call.
        io.restassured.RestAssured.given()
            .contentType(ContentType.JSON)
            .body(newStore)
            .when()
            .post("/store")
            .then()
            .statusCode(201);

        // Verify the sync was at least attempted
        verify(legacyStoreManagerGateway, timeout(1000)).createStoreOnLegacySystem(any(Store.class));
    }
}

```

---

### 2. Bonus Task: Fulfillment Junction Logic

For the bonus task, we need to link **Warehouses**, **Products**, and **Stores**. Since these are in different packages, we'll need a "Junction" entity to manage the associations.

**Tomorrow's Logic Checklist:**

* **The "2-Warehouse" Rule:** When associating a product to a store, we must query the fulfillment table: `count(warehouses) WHERE product_id = X AND store_id = Y`. If count is 2, block the addition.
* **The "3-Warehouse" Rule:** A simple count of unique warehouse IDs for a specific store.
* **The "5-Product" Rule:** A check on the specific warehouse to ensure it isn't over its variety limit.

---

### 3. Architecture Recap

We are effectively moving toward a **Modular Monolith**.

* **Stores:** Handle retail inventory.
* **Warehouses:** Handle storage and logistics.
* **Fulfillment (Bonus):** The bridge that tells a Store which Warehouse has its Products.

